\documentclass[12pt,letterpaper]{article}

\usepackage{lmodern}
\usepackage[T1]{fontenc}
%===========================
% disable section numbers
\renewcommand{\thesection}{}
\renewcommand{\thesubsection}{\arabic{section}.\arabic{subsection}}
\makeatletter
\def\@seccntformat#1{\csname #1ignore\expandafter\endcsname\csname the#1\endcsname\quad}
\let\sectionignore\@gobbletwo
\let\latex@numberline\numberline
\def\numberline#1{\if\relax#1\relax\else\latex@numberline{#1}\fi}
\makeatother
%===========================

\usepackage{amsmath} % math
\usepackage{shortvrb} % make "" behave like \texttt
\usepackage{hyperref} % hyper-referencing/link capabilities in PDF
\usepackage{xcolor} % colours for making hyperlinks look nicer
\hypersetup{
	colorlinks,
	linkcolor={red!50!black},
	citecolor={blue!50!black},
	urlcolor={blue!50!black}
}
\usepackage[margin=1in]{geometry} % control size of margins
%\usepackage{listings} % allow pretty formatting of stuff that needs pretty formatting
\usepackage{minted} % making nicely coloured code snippets
\usepackage[sorting=none]{biblatex} % bibliography
\usepackage{graphicx} % put in figures
\usepackage{siunitx} % pain-free angle representation in degrees (e.g. \ang{90}), other uses too

%=======================================

\newenvironment{custmint}[1]
{%
	\VerbatimEnvironment
	\begin{minted}{#1}%
	}
	{%
	\end{minted}%
}
\usepackage{mdframed} % for note boxes

\newmdenv[linewidth=2]{notebox} % note boxes

\MakeShortVerb" %see package shortvrb

% put something in quotation marks
\newcommand{\inquotes}[1]{``#1''}	% double quotes
\newcommand{\insquotes}[1]{`#1'}	% single quotes

% inline code short-hand
\newcommand{\ril}[1]{\mintinline[breaklines, breakanywhere]{rust}{#1}}
\newcommand{\cil}[1]{\mintinline[breaklines, breakanywhere]{c}{#1}}

\newcommand{\ash}{\texttt{ash}}

\newenvironment{indenttext}{%
	\par%
	\medskip
	\leftskip=4em\rightskip=2em%
	\noindent\ignorespaces}{%
	\par\medskip}

\let\oldquotation\quotation
\renewenvironment{quotation}{\begin{indenttext}\fontfamily{LinuxLibertineT-OsF}\selectfont}{\end{indenttext}}

%============ BIBLIOGRAPHY =============
\addbibresource{bibliography.bib}
%=======================================

\begin{document}

\title{Using Vulkan with Rust via \ash}
\date{0.1}
\author{Brian Merchant}
\maketitle
\tableofcontents
\reversemarginpar

% -----------------------------------------

\begin{abstract}
    This document provides a Rust-based introduction to using Vulkan to create graphics. \href{https://github.com/MaikKlein/ash}{\ash}, a Rust wrapper around the C Vulkan API, is used to build a series of small programs (\inquotes{samples}) which iterate upon one another towards a final goal of displaying a 3D cube.  
\end{abstract}

\section{Setup}
    Necessary: install \href{https://www.lunarg.com/vulkan-sdk/}{Vulkan SDK}.
    
    Optional: read history of Vulkan on Wikipedia.
	
\section{\inquotes{C-ish}}
	C-ish is this document's shorthand for C/C++. Since the Vulkan API is written in C, being faimilar with certain features of C-ish is useful. Additionally, many existing Vulkan tutorials use C++. 
    
    However, this document does not assume intimacy with C-ish: in fact, the author has only a passing familiarity. The following is a complete list of concepts that will be directly or indirectly referenced within the document:
		\begin{itemize}
            \item syntax and concept differences between C-ish pointers and Rust references
            
			\item C-ish \href{https://en.wikibooks.org/wiki/C_Programming/Arrays_and_strings}{array}s
            
            \item relationship between  \href{https://en.wikibooks.org/wiki/C_Programming/Pointers_and_arrays}{pointers} and \href{https://en.wikibooks.org/wiki/C_Programming/Pointers_and_arrays#Pointers_and_Arrays}{arrays} in C-ish; why will one sometimes see \cil{int*} given as the type for an array of \cil{int}s?
            
            \item C-ish \href{https://en.wikibooks.org/wiki/C_Programming/Advanced_data_types}{"struct"s and "enum"s}
            
            \item the keyword \href{https://en.wikibooks.org/wiki/C_Programming/Advanced_data_types}{\cil{typdef}}
			
            \item the keyword \cil{void}
            
            \item the keyword \cil{NULL}
            
			\item \href{https://en.wikibooks.org/wiki/C_Programming/Procedures_and_functions}{function} definition syntax; what is a \inquotes{function prototype}? 
			
			\item what a \href{https://en.wikipedia.org/wiki/Mask_(computing)}{bit mask} is, and \href{https://stackoverflow.com/questions/10493411/what-is-bit-masking}{how it's used}
            
            \item \item what does \texttt{"\textbackslash0"} do in a string? 
		\end{itemize}
    
    
\section{Introduction to Vulkan}

Vulkan provides an interface between software applications and a Vulkan-compatible physical devices. Vulkan compatible physical devices can be:
	\begin{itemize}
		\item a CPU
		\item \href{https://www.reddit.com/r/vulkan/comments/5f7jhn/is_it_possible_to_run_vulkan_on_cpu/}{a software abstraction running on top of a CPU}
		\item special purpose hardware for highly-parallel computing, e.g. a GPU;
		\item many CPUs configured to share data with each other
	\end{itemize}
A physical device is Vulkan compatible if someone has written a \inquotes{driver} meant to organize communication between the physical device and Vulkan's internals. Thus, Vulkan standardizes communication between software and a wide variety of hardware.

Vulkan commands that form the interface between application and hardware drivers are brought into action by a \inquotes{loader}. Vulkan's specification calls for its core commands and the drivers they communicate with to be highly specialized for software-silicon crosstalk, so extraneous capabilities (such as debugging conveniences) are provided through optional (chosen by the programmer) \inquotes{layers} which are placed between the loader-driver conduit.    

Thus, to begin, a programmer creates an \inquotes{instance} of the loader. Through this loader instance, they search system for physical devices with Vulkan-compatible drivers. They choose specific physical devices to work with, and set which optional features of the physical devices should be used (e.g. use 64-bit floats, or 32-bit floats?). For each physical device, the programmer defines one or more \inquotes{logical devices}: abstractions representing subsets of a physical device's resources. Each logical device is used to create \inquotes{queues}, which are selected from several types of \inquotes{queue families}. Not all physical devices may implement every type of queue family, as different queue families are specialized for transferring particular types/formats of information. Finally, the programmer enables Vulkan API \inquotes{extensions} which provide convenient functions to handle certain tasks they might be interested in (e.g. graphics display).

From now on in this document, \inquotes{device} without qualification shall refer to a \inquotes{logical device} while a physical device will only be referred to in full as \inquotes{physical device}.


\begin{quotation}
    Vulkan exposes one or more devices, each of which exposes one or more queues which may process work asynchronously to one another. The set of queues supported by a device is partitioned into families. Each family supports one or more types of functionality and may contain multiple queues with similar characteristics. Queues within a single family are considered compatible with one another, and work produced for a family of queues can be executed on any queue within that family. This Specification defines four types of functionality that queues may support: graphics, compute, transfer, and sparse memory management.
\end{quotation}

\section{0: \texttt{init-instance.rs}}

A Vulkan \emph{instance} has C-ish type \cil{vkInstance}. One could create many \cil{vkInstance}s, if it is helpful for their task, but we only need to create one. In C-ish, an instance is created by calling the function \cil{vkCreateInstance}, which has the prototype:
		\begin{minted}{c}
VkResult vkCreateInstance(
const VkInstanceCreateInfo*                 pCreateInfo,
const VkAllocationCallbacks*                pAllocator,
VkInstance*                                 pInstance);
		\end{minted}
        
		\begin{itemize}
			\item return type \cil{vkResult}: a C-ish "enum", which contains a bunch of  constants indicating the result of different Vulkan commands: in this case, success (i.e. successful creation of an instance), or some sort of a failure
			
			\item argument \cil{pCreateInfo}: a pointer to a \cil{vkInstanceCreateInfo} "struct"
			
			\item argument \cil{pAllocator}: a pointer to a \cil{vkAllocationCallbacks} "struct" whose members contain various functions you might have written to help the physical device organize its memory usage---we will tend to go simple, and not provide anything, in which case the physical device will use its default memory management routines
			
			\item argument \cil{pInstance} an \inquotes{opaque pointer} to an instance (an opaque pointer is a C-ish concept which provides a pointer to a data structure, but the pointer cannot be used to query details of the data structure, nor can it be de-referenced)
		\end{itemize}

Let us examine the "struct" \cil{vkInstanceCreateInfo}, since we need to provide \cil{vkCreateInstance} with one:
		\begin{minted}{c}
typedef struct VkInstanceCreateInfo {
	VkStructureType             sType;
	const void*                 pNext;
	VkInstanceCreateFlags       flags;
	const VkApplicationInfo*    pApplicationInfo;
	uint32_t                    enabledLayerCount;
	const char* const*          ppEnabledLayerNames;
	uint32_t                    enabledExtensionCount;
	const char* const*          ppEnabledExtensionNames;
} VkInstanceCreateInfo;
		\end{minted}
		\begin{itemize}
			\item \cil{sType}: a member common to all Vulkan \inquotes{info "struct"}s, it indicates the type of the info "struct", in this case \cil{VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO}---this is useful because in C, you might sometimes get a typeless (\cil{void*}) pointer to a particular "struct", and to determine what kind of "struct" it is, you could query the \cil{sType} field
			
			\item \cil{pNext}: another common info "struct" member, usually set to \cil{NULL} unless API extensions (and only extensions) require one to pass additional "struct"s
			
			\item \cil{flags}: for future Vulkan versions, currently no flags defined, set to "0"
			
			\item \cil{pApplicationInfo}: pointer to a \cil{VkApplicationInfo} "struct" which we will study next
			
			\item \cil{ppEnabledLayerNames}: in this tutorial, we will not be using layers, so we can set this to \cil{NULL}
			
			\item \cil{enabledLayerCount}: length of the \cil{ppEnabledLayerNames} list thus should be zero since we have \cil{ppEnabledLayerNames == NULL}
			
			\item \cil{ppEnabledExtensionNames}: at this point in the tutorial, we are not using extensions, so we'll be setting this to \cil{NULL}
			
			\item \cil{enabledExtensionCount}: length of the \cil{ppEnabledExtensionNames} list
		\end{itemize}
This "struct" has which has some members typical to many other Vulkan info "struct"s, as the reader will see. \cil{vkInstanceCreateInfo} "struct" requires as a member an instance of the \cil{VkApplicationInfo} "struct" meant to provide some information regarding the application initializing the loader:
		\begin{minted}{c}
typedef struct VkApplicationInfo {
	VkStructureType    sType;
	const void*        pNext;
	const char*        pApplicationName;
	uint32_t           applicationVersion;
	const char*        pEngineName;
	uint32_t           engineVersion;
	uint32_t           apiVersion;
} VkApplicationInfo;
		\end{minted}
	\begin{itemize}
		\item \cil{sType}, \cil{pNext}: common features of many Vulkan info "struct"s, see the \cil{vkInstanceCreateInfo} "struct"'s member overview, as these are the same;
		
		\item \cil{pApplicationName}, \cil{applicationVersion}, \cil{pEngineName}, \cil{engineVersion}: for general use, e.g. sometimes drivers may be designed to execute special behaviour for certain application---this can be used to let them know which application they are dealing with
		
		\item \cil{apiVersion}:  this field communicates the major, minor, and patch levels of the Vulkan API used by the application; we'll be using "VK\_API\_VERSION\_1\_0" (major is "1", minor is "0").
	\end{itemize}

In "/init-instance/src/main.rs" we initialize a loader. Points to note and questions to consider:
	\begin{itemize}
		\item comments explaining \ril{use} statements
		
		\item \ril{unsafe} block: \ash an almost one-to-one interface to the Vulkan C API, thus many of Rust's safety features have to be disabled
		
		\item for fields like \cil{pApplicationName} we create a \ril{std::ffi::CString} and then pass it \inquotes{raw} (i.e. as a pointer) by calling \ril{as_ptr}, rather than using the standard Rust \ril{String}
		
		\item \ril{vk::StructureType} is used to fill out \ril{s_type} fields
		
		\item can you explain how the \ril{flags} field is filled out? (hint: look up the definition of the \ril{vk::InstanceCreateInfo} "struct" in \href{https://docs.rs/ash}{\ash's documentation} and then answer: what type is \ril{flags}? How is the \ril{std::Default} trait implemented for it?)
		
		\item that to actually use Vulkan, we first initialize an \ril{ash::Entry} "struct" which contains the supporting infrastructure to allow Rust to interface with Vulkan's C implementation
		
		\item the \ril{ash::Entry} "struct" also has some \ril{impl}s which put syntactic sugar around calling functions like \ril{vkCreateInstance}, in particular the function \ril{create_instance}---can you find where that function is implemented? (hint: open up \href{https://docs.rs/ash}{\ash's documentation}, and 1) figure out where the \ril{EntryV1_0} trait is defined, 2) figure out where \ril{Entry<V>} is defined, and 3) how is the \ril{EntryV1_0} implemented for \ril{Entry<V1_0>}?)
		
		\item we have to manually destroy the instance once we're done
	\end{itemize} 
	
To see everything in action: 
	\begin{center}
		"cargo run --bin init-instance"
	\end{center}
	
\section{1: \texttt{enumerate-devices.rs}}
	Obtaining a list of information from the loader is a common operation, and in the course of this tutorial, we will note that there is a pattern to how the API handles these operations. The pattern is well demonstrated by the next task: querying the loader for a list of available Vulkan-compatible physical devices on the host system. We call the function \cil{vkEnumeratePhysicalDevices}, which has prototype
	\begin{minted}{c}
VkResult vkEnumeratePhysicalDevices(
	VkInstance                                  instance,
	uint32_t*                                   pPhysicalDeviceCount,
	VkPhysicalDevice*                           pPhysicalDevices);
	\end{minted}
    
    The specification explains the function's arguments succinctly:
        \begin{quotation}
            If "pPhysicalDevices" is "NULL", then the number of physical devices available is returned in "pPhysicalDeviceCount". Otherwise, "pPhysicalDeviceCount" must point to a variable set by the user to the number of elements in the "pPhysicalDevices" array, and on return the variable is overwritten with the number of handles actually written to "pPhysicalDevices". If "pPhysicalDeviceCount" is less than the number of physical devices available, at most "pPhysicalDeviceCount" structures will be written. If "pPhysicalDeviceCount" is smaller than the number of physical devices available, "VK_INCOMPLETE" will be returned instead of "VK_SUCCESS", to indicate that not all the available physical devices were returned.
        \end{quotation}
    
    Assume we have a \cil{vkInstance} called \cil{instance} created, as explained in the last section, and a pointer to memory where we can store an unsigned integer \cil{pPhysicalDeviceCount}. Then, for our purposes, we would:
		\begin{enumerate}
            \item call \cil{vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, NULL)} since we do not have a pre-existing array of devices, and are interested in finding out how many such devices exist; if \cil{vkResult} indicates success ("VK_SUCCESS" is returned), then \cil{pPhysicalDeviceCount} now points to an integer counting the number of physical devices available otherwise the specification states we get errors "VK_ERROR_OUT_OF_HOST_MEMORY", "VK_ERROR_OUT_OF_DEVICE_MEMORY", "VK_ERROR_INITIALIZATION_FAILED"
			
			\item assuming success, create an empty array of \cil{VkPhysicalDevice}s containing enough space for \cil{*pPhysicalDeviceCount} items "pPhysicalDevices" ("p" in the variable name stands for \inquotes{pointer})
			
			\item call \cil{vkEnumeratePhysicalDevices(instance, pPhysicalDeviceCount, pPhysicalDevices}---if \cil{vkResult} indicates success, then our list \cil{pPhysicalDevices} should be filled out with the \cil{vkPhysicalDevice}s
		\end{enumerate}
	
	In Rust-land, the \ril{ash::Instance} "struct" has an \ril{impl} function \ril{ash::Instance::enumerate_physical_devices}, which calls \cil{vkEnumeratePhysicalDevices} and returns a vector of \ril{vk::PhysicalDevice}s. The reader should look at the source code of this function:  \href{https://gist.github.com/bzm3r/175cd2b63db8f783ed968df20462be67}{gist link for annotated \ril{enumerate_physical_devices}}. To find the source, go to \ash's documentation for \ril{ash::Instance}, and click the appropriate "[src]" links. You can see that under the hood, \ash performs the operations we outlined above. 
	
	"enumerate-devices.rs" contains the code to enumerate physical devices on a system and print out how many were found. Note that before the program panics intentionally, care is taken to ensure that any instances we create are destroyed with the help of the \ril{unsafe} function \ril{destroy_instance_and_panic}. Run the program with the command: 
		\begin{center}
			"cargo run --bin enumerate-devices"
		\end{center}
    
	
\section{2: \texttt{init-device.rs}}

    The rest of this document assumes the at least one physical device exists on the host system. Creation of logical device abstractions over found physical devices will now be explored. Apart from organizing available physical resources, a logical device allows for the creation of queues which pass data between applications and physical devices. 
		
	For the sake of simplicity, let us select the first (perhaps only) physical device found. What queue families (types of queues) does it support? The list of available queue families can be obtained by calling \cil{vkGetPhysicalDeviceQueueFamilyProperties}, which has prototype:
		\begin{minted}{c}
void vkGetPhysicalDeviceQueueFamilyProperties(
	VkPhysicalDevice                            physicalDevice,
	uint32_t*                                   pQueueFamilyPropertyCount,
	VkQueueFamilyProperties*                    pQueueFamilyProperties);
		\end{minted}
	This function has the same organization as "vkEnumeratePhysicalDevices" seen in the previous section: after all, it too returns a list of data. Thus, similar to \ril{ash::Instance::enumerate_physical_devices}, \ash wraps the querying process in the "impl" function \ril{ash::Instance::get_physical_device_queue_family_properties}. Examining this function's source will reveal its similarities to \ril{ash::Instance::enumerate_physical_devices}. A successful call to \cil{get_physical_device_queue_family_properties} provides a list:  \ril{Vec<vk_sys::QueueFamilyProperties>}.
		
	What's inside C-ish \cil{vkQueueFamilyProperties}?
	   \begin{minted}{c}
typedef struct VkQueueFamilyProperties {
	VkQueueFlags    queueFlags;
	uint32_t        queueCount;
	uint32_t        timestampValidBits;
	VkExtent3D      minImageTransferGranularity;
} VkQueueFamilyProperties;

typedef enum VkQueueFlagBits {
	VK_QUEUE_GRAPHICS_BIT = 0x00000001,
	VK_QUEUE_COMPUTE_BIT = 0x00000002,
	VK_QUEUE_TRANSFER_BIT = 0x00000004,
	VK_QUEUE_SPARSE_BINDING_BIT = 0x00000008,
} VkQueueFlagBits;
	   \end{minted}
		\begin{itemize}
			\item \cil{queueCount}: unsigned integer specifying how many queues this device has 
			\item \cil{vkQueueFlags}: a bit mask of one or more \cil{VkQueueFlagBits} specifying the capabilities of queues in this family (some or all of Graphics, Compute, Transfer or Sparse).
		\end{itemize}
		
	\ash has a special type for these flag bits, \ril{ash::types::QueueFlags}, which also allow bitwise operations. Thus, we can convert the returned flag from hexadecimal to binary to determine the queue family's capabilities:
    	\begin{align*}
    		\mathtt{0x1} &\rightarrow 000\underline{1} && \text{Graphics}\\
    		\mathtt{0x2} &\rightarrow 00\underline{1}0 && \text{Compute}\\
    		\mathtt{0x3} &\rightarrow 0\underline{1}00 && \text{Transfer}\\
    		\mathtt{0x4} &\rightarrow \underline{1}000 && \text{Sparse}
    	\end{align*}
     For example, the flag "0xF" is $1111$ in binary, meaning that the queue family supports Graphics, Compute, Transfer, and Sparse operations, while flag "0x5", in binary is $0101$, meaning that only Graphics and Transfer operations are supported.
         
	To test whether a particular bit is set (i.e. is $1$), the \ril{subset} \ril{impl} for \ril{ash::types::QueueFlags} can be used, as demonstrated by  \ril{get_queue_family_supported_ops} in "init-device-0.rs". This program prints out queue families supported by the first physical device in the list of physical devices available on the host system.
		
\subsection{\texttt{init-device-and-queue.rs}}
	"init-device.rs" will now be iterated upon by by adding functionality to choose a physical device which has a queue family with graphics capability, since the tutorial ultimately aims to display a cube. One an appropriate physical device has been chosen, a \emph{logical device} is created on it, which will be used to create a queue from the graphics family. A broad outline for executing this procedure using the C-ish API is:
		\begin{enumerate}
			\item fill out a \cil{VkDeviceQueueCreateInfo} "struct" based on the queue family selected for each queue that will be created, and store each such "struct" in an array, perhaps called \cil{pQueueCreateInfos}
				
			\item fill out a \cil{VkDeviceCreateInfo} "struct", which amongst other members, requires \cil{pQueueCreateInfos}
                
			\item call \cil{vkCreateDevice}, which takes as an argument \cil{VkDeviceCreateInfo}, and will create \cil{vkDevice} upon success
				
			\item perform any tasks we need to with the resulting \cil{vkDevice}
				
			\item destroy the device
		\end{enumerate}
		
	Let us look at \cil{VkDeviceQueueCreateInfo}:
\begin{minted}{c}
typedef struct VkDeviceQueueCreateInfo {
	VkStructureType             sType;
	const void*                 pNext;
	VkDeviceQueueCreateFlags    flags;
	uint32_t                    queueFamilyIndex;
	uint32_t                    queueCount;
	const float*                pQueuePriorities;
} VkDeviceQueueCreateInfo;
\end{minted}
	\begin{itemize}
		\item \cil{flags}: for use by future Vulkan versions, set to 0 
			
		\item \cil{queueFamilyIndex}: index of the queue's queue family properties in the array \cil{vkQueueFamilyProperties}
			
		\item \cil{queueCount}: the number of queues to be created (shouldn't be greater than the number of queues supported by the physical device, as specified in the queue family's properties!)
			
		\item \cil{pQueuePriorities}: an array of \cil{queueCount} normalized floating point values (i.e. "float"s between 0.0 and 1.0), denoting the relative priority of each queue we're creating: 0.0 is lowest priority, 1.0 is highest; within the physical device, queues with higher priority will have a higher chance of being allotted more processing time than queues with lower priority; more on this later
	\end{itemize}
		
	The "struct" \cil{VkDeviceCreateInfo} is defined like:
    \begin{minted}{c}
typedef struct VkDeviceCreateInfo {
    VkStructureType                    sType;
    const void*                        pNext;
    VkDeviceCreateFlags                flags;
    uint32_t                           queueCreateInfoCount;
    const VkDeviceQueueCreateInfo*     pQueueCreateInfos;
    uint32_t                           enabledLayerCount;
    const char* const*                 ppEnabledLayerNames;
    uint32_t                           enabledExtensionCount;
    const char* const*                 ppEnabledExtensionNames;
    const VkPhysicalDeviceFeatures*    pEnabledFeatures;
    } VkDeviceCreateInfo;
\end{minted}
	\begin{itemize}
		\item \cil{queueCreateInfoCount}: how many queue groups are to be associated with this logical device (each group will have its own \cil{vkDeviceQueueCreateInfo} "struct")
			
		\item \cil{pQueueCreateInfos}: list of \cil{vkDeviceQueueCreateInfo} "struct"s (count given by \cil{queueCreateInfoCount})
			
		\item \cil{enabledLayerCount} and \cil{ppEnabledLayerNames}: deprecated and ignored
			
   		\item \cil{enabledExtensionCount} and \cil{ppEnabledExtensionNames}: to be discussed later in the document, for now \cil{0} and \cil{NULL} respectively
   		
   		\item \cil{pEnabledFeatures}: to be discussed later in the document, for now \cil{NULL}
   	\end{itemize}
	
    Hints of more advanced features available, such as Vulkan API extensions or optional physical device features are beginning to appear, but we ignore these for the time being.
		
	The analogues of \cil{VkDeviceQueueCreateInfo} and \cil{VkDeviceCreateInfo} in \ash are \ril{vk::DeviceQueueCreateInfo} (\href{https://docs.rs/ash/0.20.2/ash/vk/types/struct.DeviceQueueCreateInfo.html}{docs}) and \ril{vk::DeviceCreateInfo} (\href{https://docs.rs/ash/0.20.2/ash/vk/types/struct.DeviceCreateInfo.html}{docs}) respectively. "init-device-1.rs" selects a physical device graphics capable queue families, fills out \ril{vk::DeviceQueueCreateInfo} and \ril{vk::DeviceCreateInfo}, and then calls \ril{ash::Instance::create_device}. Before exiting, it cleans up by destroying the created device, and the underlying loader instance. This example only creates one queue, but if more were to be created, we would provide a Rust array or vector of \ril{vk::DeviceQueueCreateInfo} in raw pointer form through \ril{.as_ptr}. This provides a C-ish style list of objects, which can be accessed through offsetting of the pointer.
		
	Study the code in "init-device-and-queue.rs" and then run it:
    	\begin{center}
    		"cargo run --bin init-device-and-queue"
    	\end{center}
      
\section{\texttt{init-command-buffer.rs}}
	With Vulkan, applications records commands in a command buffer, which is passed on to underlying drivers Since instructions are received in batches stored in buffers, drivers are able to use knowledge of upcoming instructions to optimize execution of the entire set. 
    
	However, naive implementations for creating and destroying individual command buffers can be very inefficient, so Vulkan provides \inquotes{command buffer pools}, which manage the creation and destruction of command buffers using \inquotes{pool allocators}. Furthermore, pools manage sending large groups of (small) command buffers with increased efficiency. Since pools are allocated based on the type of queue family they will pass command buffers to, every command buffer pool is associated with a single queue family available from the physical device.
	
	To create a command buffer pool, a \cil{vkCommandPoolCreateInfo} "struct" is submitted to the \cil{vkCreateCommandPool} function:
	\begin{minted}{c}
typedef struct VkCommandPoolCreateInfo {
	VkStructureType             sType;
	const void*                 pNext;
	VkCommandPoolCreateFlags    flags;
	uint32_t                    queueFamilyIndex;
	} VkCommandPoolCreateInfo;

VkResult vkCreateCommandPool(
    VkDevice                                    device,
    const VkCommandPoolCreateInfo*              pCreateInfo,
    const VkAllocationCallbacks*                pAllocator,
    VkCommandPool*                              pCommandPool)
	\end{minted}
		\begin{itemize}
			\item \cil{sType}: set to \cil{VK_STRUCTURE_TYPE_COMMAND_POOL_CREATE_INFO}
			
			\item \cil{pNext}: typical info "struct" member
			
			\item \cil{flags}: a bitmask of \cil{VkCommandPoolCreateFlagBits} indicating pool usage and behaviour attributes. Possible bits are:
				\begin{itemize}
					\item \cil{VK_COMMAND_POOL_CREATE_TRANSIENT_BIT} (0x1): command buffers allocated from the pool will be short-lived
					
					\item \cil{VK_COMMAND_POOL_CREATE_RESET_COMMAND_BUFFER_BIT} (0x2): when a command buffer is first allocated is in the initial state, and command pools with the reset bit set allow buffers from the pool to be reset to their initial state
				\end{itemize}
			
			\item \cil{queueFamilyIndex}: index of the queue family that the command pool will be associated with 
            
			\item \cil{device}: logical device which will manage creating the command pool
			
			\item \cil{pCreateInfo}: a pointer to a filled out \cil{vkCreateCommandPool} "struct"
			
			\item \cil{pAllocator}: standard input described in earlier sections
			
			\item \cil{pCommandPool}: a pointer to a \cil{vkCommandPool}, which \cil{vkCreateCommandPool} will associate with the newly created pool
		\end{itemize}
    
	Once we have a command pool,  we store it in a \cil{VkCommandBufferAllocateInfo} "struct", which is submitted to a call of \cil{vkAllocateCommandBuffers}:
		\begin{minted}{c}
typedef struct VkCommandBufferAllocateInfo {
	VkStructureType         sType;
	const void*             pNext;
	VkCommandPool           commandPool;
	VkCommandBufferLevel    level;
	uint32_t                commandBufferCount;
	} VkCommandBufferAllocateInfo;
    
VkResult vkAllocateCommandBuffers(
    VkDevice                                    device,
    const VkCommandBufferAllocateInfo*          pAllocateInfo,
    VkCommandBuffer*                            pCommandBuffers);
		\end{minted}
        
		\begin{itemize}
			\item \cil{sType}: set to \cil{VK_STRUCTURE_TYPE_COMMAND_BUFFER_ALLOCATE_INFO}
			
			\item \cil{pNext}: standard info "struct" member
			
			\item \cil{commandPool}: command pool that we created
			
			\item \cil{level}: the "enum" \cil{VkCommandBufferLevel} has values \cil{VK_COMMAND_BUFFER_LEVEL_PRIMARY} and \cil{VK_COMMAND_BUFFER_LEVEL_SECONDARY}, which specify whether this command buffer is primary or secondary. A primary command buffer can be submitted to a queue but cannot be called by another command buffer, while a secondary command buffer cannot be submitted to a queue, but can be called by another command buffer. 
			
			\item \cil{commandBufferCount}: how many buffers to make with these settings

			\item \cil{vkDevice}: the device with which the command pool is associated
			
			\item \cil{pAllocateInfo}: pointer to a filled out \cil{VkCommandBufferAllocateInfo} struct
			
			\item \cil{VkCommandBuffer}: a pointer to an array of \cil{VkCommandBuffer}s where the newly created command buffers will be stored (so, the array should have length at least \cil{commandBufferCount} set in the \cil{VkCommandBufferAllocateInfo} "struct")
		\end{itemize}
	
	Let's now turn our attention to Rust and \ash, where we'd follow (similar to C-ish) the following steps to create a command pool, and then command buffers associated with that pool:
		\begin{enumerate}
			\item we store info used to create a command pool in a \ril{vk::CommandPoolCreateInfo} "struct"
			
			\item a logical device (with type \ril{Device<V1_0>} in our tutorial so far) has an \ril{impl} \ril{create_command_pool} for creating a command pool
			
			\item we store info used to allocate command buffers in a \ril{vk::CommandBufferAllocateInfo} "struct"
			
			\item a logical device (with type \ril{Device<V1_0>} in our tutorial so far) has an \ril{impl} \ril{allocate_command_buffers} for allocating buffers
			
			\item use command pool as necessary
			
			\item destroy command pool with a logical device's (with type \ril{Device<V1_0>} in our tutorial so far) \ril{impl} \ril{destroy_command_pool}
		\end{enumerate}
	In "init-command-buffer.rs", you can see how these steps are straightforwardly executed using \ash. However, note that our clean ups are becoming more complicated and have a look at the new function \ril{clean_up}. 
	
	In coming sections, we will record commands to command buffers, but note that recording commands in the buffer does not make the GPU do anything until the command buffer is submitted using a \cil{vkQueueSubmit} call. We have much to do before we will make this call, which will be made in the last part of this tutorial series.
	
\section{\texttt{init-swap-chain.rs}}
	In this section, we'll learn how to initialize the \inquotes{swap chain}, sometimes also written as \inquotes{swapchain}. What is a swap chain? Well, Wikipedia says it best\autocite{wiki:swap-chain}:
		\begin{indenttext}
			In computer graphics, a swap chain is a series of virtual framebuffers utilized by the graphics card and graphics API [in our case, Vulkan] for frame rate stabilization and several other functions. The swap chain usually exists in graphics memory, but it can exist in system memory as well. The non-utilization of a swap chain may result in stuttering rendering, but its existence and utilization are required by many graphics APIs...In every swap chain there are at least two buffers. The first framebuffer, the screenbuffer, is the buffer that is rendered to the output of the video card. The remaining buffers are known as backbuffers. Each time a new frame is displayed, the first backbuffer in the swap chain takes the place of the screenbuffer, this is called presentation or swapping...(see also Figure \ref{fig:swap-chain-depiction})
		\end{indenttext}
	
		\begin{figure}
			\centering
			\includegraphics[width=0.7\linewidth]{swap-chain-depiction}
			\caption{An abstract depiction of the swap chain. \href{https://en.wikipedia.org/wiki/File:Swap_chain_depiction.svg}{Source.}}
			\label{fig:swap-chain-depiction}
		\end{figure}

	So, the output of the graphics device is buffered through the use of swap chains, in order to give the end-user the illusion that rendering is smooth, by making the frames appear one after the other at a constant, rather than variable rate.
	
	The core Vulkan API is platform (e.g. Windows, GNU/Linux, MacOS) and physical device (see Introduction) agnostic. In order to expose capabilities provided by a particular platform or physical device, the core API has to be extended by special extensions which take into account details relevant to the particular platform or physical device. Many of these extensions are provided and maintained by the Khronos Group itself, and we will now augment the core API with an extension that will allow it to deal with physical devices' specific implementations of swap chains. 
	
	So, how does one enable the relevant extension? Recall the info "struct" we had to fill out in order to create a logical device:
\begin{minted}{c}
typedef struct VkDeviceCreateInfo {
	VkStructureType                    sType;
	const void*                        pNext;
	VkDeviceCreateFlags                flags;
	uint32_t                           queueCreateInfoCount;
	const VkDeviceQueueCreateInfo*     pQueueCreateInfos;
	uint32_t                           enabledLayerCount;
	const char* const*                 ppEnabledLayerNames;
	uint32_t                           enabledExtensionCount;
	const char* const*                 ppEnabledExtensionNames;
	const VkPhysicalDeviceFeatures*    pEnabledFeatures;
} VkDeviceCreateInfo;
\end{minted}
	When we last looked at this "struct", we ignored \cil{enabledExtensionCount} and \cil{ppEnabledExtensionNames}, but in this section, we'll fill these out. For creating and managing swap chains, we are interested in the extension "VK\_KHR\_swapchain", so we'd pass a list containing that string, and the count of that list. 
	
	With \ash, we'd do this as follows:
		\begin{enumerate}
			\item \ril{use ash::extensions::Swapchain}: loads the module which contains swap chain extension related stuff. In particular, the \ril{ash::extensions::{DebugReport, Surface, Swapchain}} "struct" has function pointer members (i.e. members which are basically functions), \ril{impl}s that will be of great use to us
				
			\item Create an array with the right string, by using the \ril{name} static \ril{impl} of \ril{Swapchain} (track down the source for \ril{Swapchain::name} as an exercise): 
\begin{minted}{rust}
let device_extension_names_pointers = [Swapchain::name().as_ptr()];
\end{minted}
			
			\item set the \ril{enabled_extension_count} and \ril{pp_enabled_extension_names} members of the \ril{vk::DeviceCreateInfo} "struct" we fill out using \ril{device_extension_names_pointers.len() as u32} and \ril{device_extension_names_pointers} respectively
		\end{enumerate}
	
	Thus, when we create \ril{device} in "init-swap-chain.rs", we'll have enabled the swap chain extension. 
	
	In C-ish our next step will be to set up the \cil{VkSwapchainCreateInfoKHR} info "struct":
\begin{minted}{c}
typedef struct VkSwapchainCreateInfoKHR {
	VkStructureType                  sType;
	const void*                      pNext;
	VkSwapchainCreateFlagsKHR        flags;
	VkSurfaceKHR                     surface;
	uint32_t                         minImageCount;
	VkFormat                         imageFormat;
	VkColorSpaceKHR                  imageColorSpace;
	VkExtent2D                       imageExtent;
	uint32_t                         imageArrayLayers;
	VkImageUsageFlags                imageUsage;
	VkSharingMode                    imageSharingMode;
	uint32_t                         queueFamilyIndexCount;
	const uint32_t*                  pQueueFamilyIndices;
	VkSurfaceTransformFlagBitsKHR    preTransform;
	VkCompositeAlphaFlagBitsKHR      compositeAlpha;
	VkPresentModeKHR                 presentMode;
	VkBool32                         clipped;
	VkSwapchainKHR                   oldSwapchain;
} VkSwapchainCreateInfoKHR;
\end{minted}
	\begin{itemize}
		\item \cil{sType} and \cil{pNext} are standard info "struct" fields, while \cil{flags} is for future use and set to 0 
		
		\item \cil{surface}: surface to which this swap chain will present to (more about surfaces coming up right after)
		
		\item \cil{minImageCount}: how \inquotes{deep} the swap chain should be (how many buffers it should have between input and output) 
		
		\item \cil{imageFormat}: format of the data representing the images (i.e. pixel encoding format) the swap chain will be handling, a value from the \href{http://vulkan-spec-chunked.ahcox.com/ch31s03.html#VkFormat}{\cil{VkFormat} "enum"}
        
		\item \cil{imageColorSpace}: specifies which \href{https://en.wikipedia.org/wiki/Color_space}{colour space} the presentation engine will interpret each pixel (recall that pixels store color information) \href{http://vulkan-spec-chunked.ahcox.com/ch29s05.html#VkColorSpaceKHR}{\cil{VkColorSpaceKHR}}
		
		\item \cil{imageExtent}: maximum size of the images the swap chain will handle
		
		\item \cil{imageArrayLayers}: relevant for applications that will be presenting monitors that take advantage of the \href{https://en.wikipedia.org/wiki/Stereo_display}{stereoscopic effect} to provide the illusion of 3D images---we'll just set the value to 1, as we are making an application that will display on standard monitors
		
		\item \cil{imageUsage}: a bitmask of \href{http://vulkan-spec-chunked.ahcox.com/ch11s03.html#VkImageUsageFlagBits}{VkImageUsageFlagBits} specifying how the application will use the images
		
		\item \cil{imageSharingMode}: a value from the \href{https://www.khronos.org/registry/vulkan/specs/1.0/man/html/VkSharingMode.html}{VkSharingMode} "enum", specifying whether access to data in the swap chain is exclusive to queues from one family, or whether access is open to queues from multiple queue families:
			\begin{itemize}
				\item \cil{queueFamilyIndexCount} and \cil{pQueueFamilyIndices}: if concurrent access between queue families is allowed, which families have permission?
			\end{itemize}
		
		\item \cil{preTransform}: a bitmask of \href{http://vulkan-spec-chunked.ahcox.com/ch29s05.html#VkSurfaceTransformFlagBitsKHR}{VkSurfaceTransformFlagBitsKHR} bits, which specifies how to transform (e.g. rotate, mirror, etc.) the images in the swap chain relative to the \inquotes{natural} orientation of the presentation device (e.g. a monitor); to understand this better, consider this contrived example: hanging upside down while using a computer is a new health fad, but your monitor is locked to the table its on, so your application sets the \cil{preTransform} bitmask to rotate the image by $\ang{180}$ so that the image appears right side up while you're upside down
		
		\item \cil{compositeAlpha}: a bitmask of \href{http://vulkan-spec-chunked.ahcox.com/ch29s05.html#VkCompositeAlphaFlagBitsKHR}{VkCompositeAlphaFlagBitsKHR} bits, indicating how the images should be \href{https://en.wikipedia.org/wiki/Alpha_compositing}{alpha composited} together
		
		\item \cil{presentMode}: value from \href{http://vulkan-spec-chunked.ahcox.com/ch29s05.html#VkPresentModeKHR}{\cil{VkPresentModeKHR}} "enum"; how will the presentation engine ask for data from the swap chain?
		
		\item \cil{clipped}: should the underlying infrastructure care about pixels that are outside the image extents relevant for this swap chain?
		
		\item \cil{oldSwapchain}: pointer to the old swap chain that this new swap chain is going to replace (\cil{NULL} usually)
		\item 
	\end{itemize}
	
	As you can see, there's a lot of infrastructure involved in taking image data from a physical device, and then displaying it to a user. The rest of this section is going to go over how to fill out this structure.
	
	It is the \inquotes{windowing system} (e.g. X Window System, MS Windows, Wayland) which is responsible for displaying the data stored in a swap chain, by providing us with a \inquotes{surface} abstraction onto which data is drawn. Note that the windowing system is separate from the core Vulkan API, but there are Khronos Group maintained extensions to Vulkana (different ones for different windowing systems) which allow it to integrate with the windowing system (Window System Integration, or WSI). The relevant extension in this case will be specified in the info "struct" used to create the instance.
	
	Getting the name of the relevant extension using \ash needs a bit more care this time, because the extension to be used depends upon which platform our application is on. First, we should load the relevant extension modules: \ril{use ash::extensions::{Surface, Win32Surface, XlibSurface}}, then we write functions that will \href{https://doc.rust-lang.org/book/first-edition/conditional-compilation.html}{conditionally compile} based on which platform we are on:
\begin{minted}{rust}
#[cfg(all(unix, not(target_os = "android")))]
fn extension_names() -> Vec<*const i8> {
	vec![
		Surface::name().as_ptr(),
		XlibSurface::name().as_ptr(),
	]
}

#[cfg(all(windows))]
fn extension_names() -> Vec<*const i8> {
	vec![
		Surface::name().as_ptr(),
		Win32Surface::name().as_ptr(),
	]
}
\end{minted}

	Now we have surface related extensions loaded, but we still can't create a surface, until there is a window which can be associated with the surface. In C-ish, there are various windowing libraries, but in Rust, we'll use \ril{extern crate winit}. 
	
	\subsection{Creating a window}
		The following code in "init-swap-chain.rs" is relevant to creating a window:
			\begin{minted}{rust}
let events_loop = winit::EventsLoop::new();

let window = winit::WindowBuilder::new()
.with_title("Ash - Example")
.with_dimensions(window_width, window_height)
.build(&events_loop)
.unwrap();
			\end{minted}
			
		Let's understand what is going on here. First of all, we create an \href{https://en.wikipedia.org/wiki/Event_loop#Windows_applications}{event loop}. An event loop essentially handles messages sent between the user interface (the window), and our application. For instance, if the user presses a key, the event loop will notify our application of this, and allow it to choose what to do. It is worth taking a look at \href{https://docs.rs/winit/0.10.0/winit/struct.EventsLoop.html}{the documentation} for \ril{winit::EventsLoop}. Once we have the events loop set up, we build a window, using several pretty self-explanatory calls which provide the title, definition and so on. This tutorial will not spend much time discussing the internals of the window system, which depend heavily upon the particular platform the application is running on. Now that we have a \ril{window}, we can create a surface. Again, these functions are going to be platform dependent: have a look at them (\ril{create_surface}) within the source code for this example. 
        
        Find a queue that is capable of presentation.
        
        
    
    The gist of what is happening in these functions is that 
        
\section{Thanks}
	The information in this tutorial was derived from multiple sources (\inquotes{"<search engine> is your best friend!"}), but some stand prominent amongst them. Grateful thanks is owed to:
		\begin{enumerate}
			\item \href{https://vulkan.lunarg.com/doc/sdk/1.0.65.1/windows/tutorial/html/index.html}{LunarG's Vulkan Samples Progression}, whose progression structure I found comforting, and thus stole, along with some conceptual explanations. 
			
			\item Alexander Overvoorde's \href{https://vulkan-tutorial.com/}{Vulkan Tutorial}, whose rich coverage often provided some clues on things other's assumed a beginner would know---this tutorial does not even come close to covering the range of material Overvoorde's tutorial does.
			
			\item \href{Maik Klein}{https://github.com/MaikKlein}, who began writing \ash, and is its prime contributor. Also, Maik and \href{https://github.com/msiglreith}{msiglreith} on \ash's Gitter were happy to answer my questions.
			
			\item The many people behind open software projects such as Vulkan and Rust, who build vast infrastructure to provide ease that we take for granted. 
		\end{enumerate}
\printbibliography
\end{document}
