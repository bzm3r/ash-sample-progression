\documentclass[12pt,letterpaper]{article}

\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{shortvrb} % make "" behave like \texttt
\usepackage{hyperref} % hyper-referencing/link capabilities in PDF
\usepackage[margin=1in]{geometry} % control size of margins
%\usepackage{listings} % allow pretty formatting of stuff that needs pretty formatting
\usepackage{minted} % making nicely coloured code snippets

\MakeShortVerb" %see package shortvrb

% put something in quotation marks
\newcommand{\inquotes}[1]{``#1''}	% double quotes
\newcommand{\insquotes}[1]{`#1'}	% single quotes

% inline code short-hand
\newcommand{\ril}[1]{\mintinline{rust}{#1}}
\newcommand{\cil}[1]{\mintinline{c}{#1}}

\begin{document}

\title{Using Vulkan with Rust via Ash: A Samples Tutorial}
\date{0.1}
\author{Brian Merchant}
\maketitle
\reversemarginpar

% -----------------------------------------

\section{Introduction}

Vulkan provides an interface between your application, and a Vulkan device, which the application wants to use for highly-parallel computation typical of graphics tasks, but also useful elsewhere. Vulkan can interface with many different types of \emph{physical devices}:
	\begin{itemize}
		\item the CPU of your system;
		\item \href{https://www.reddit.com/r/vulkan/comments/5f7jhn/is_it_possible_to_run_vulkan_on_cpu/}{a software abstraction running on top of the CPU};
		\item special purpose hardware for highly-parallel computing, e.g. a GPU;
		\item many CPUs configured to share data with each other;
		\item etc.
	\end{itemize}
Note that each one of these devices also should have some memory, where instructions, input data, and output data may be stored. Vulkan allows your application to interface with all these different \inquotes{physical devices} and their memory, regardless of the details of each device's configuration, as long as the physical device provides a Vulkan-compatible \inquotes{driver}, which would be a piece of software that provides a Vulkan interface to the underlying hardware. Thus, as an application programmer, you only need to worry about interfacing your application with Vulkan, while the drivers handle interfacing Vulkan with the hardware. 

Note that the driver doesn't do anything beyond helping Vulkan pass instructions to the hardware, so verifying whether the instructions you send make sense, or whether the resulting data from a computation is not garbage, is your task. However, during development of your application, you can specify additional software \emph{layers} between your application's \inquotes{loader} (i.e. its Vulkan communication object) and the physical device's driver, which can help to debug and verify the correctness of the instructions you are passing through the loader. You can choose to turn on and off these loaders as you wish.

Let's now take a closer look at the loader, which is more specifically called an \inquotes{instance}. When you first create the instance, it searches your system for physical devices with Vulkan-compatible drivers, and enumerates these for you, so that you can choose which physical device(s) you would like to work with. Once you have chosen specifical physical devices, you can describe more specifically which features of each physical device you would like to use (e.g. 64-bit floats, or 32-bit floats?). Each physical device can then be abstracted into \inquotes{logical devices}, which represent subsets of a physical device's resources. For example, let us say your application needs to do some graphics calculations, and some simulation related calculations: so to organize your physical device(s)' computing resources, you could set one logical device to deal with the graphics, and the other logical device could be set to deal with calculations. Thus, specification of logical devices is an abstraction that helps you organize computing resources. Each logical device allows you to create \inquotes{queues}, which are selected from \inquotes{queue families}. Queues organize the communication of data from your application (e.g. computation instructions, or some data to be manipulated) to the physical device's driver, and they also organize communication of data from your physical device to your application (e.g. results of computations, or status of the device's computing efforts). Queue families represent specialization of queues: queues to handle data (memory) transfers, queues to handle instruction transfer, etc. Note that sometimes, only certain queue families may be available on certain physical devices (and their availability may indicate what role the physical device is specialized for), but common physical devices tend to support all commonly used queue families. Finally, we may also take advantage of functionality provided by Vulkan \inquotes{extensions}, which are API extensions that provide common functionality for some often-occurring Vulkan use-cases (e.g. graphics display).

We are interested in using Rust to write our application, but the Vulkan API is written in C, so we use \href{https://github.com/MaikKlein/ash}{Ash}, which is a lightweight (thus unsafe) Rust wrapper around Vulkan. This document will teach you how to use Vulkan through Ash, by helping you build a series of small programs (\inquotes{samples}) which iterate upon each other towards a final product (displaying a cube). 

\section{Instances, Devices and Queues}

	A Vulkan \emph{instance} is a software object which your application uses to interact with Vulkan device(s). The physical device(s) in your computing system that one can use Vulkan to interact with are represented as members of the instance. Commands from your application are passed through a Vulkan instance into a \emph{queue} (each associated with a logical device abstracting a subset of the physical device's resources) which pipes to and from the physical device. 
	
	Note that since an instance is a software abstraction, if necessary, one could have several instances interacting with one physical device, if it provides value to how your application abstracts your physical devices. For now though, we'll focus on using one instance.
	
\section{\texttt{init-instance}}
	
	If we were using C, an instance is created by calling the function \cil{vkCreateInstance}, which has the prototype:
		\begin{minted}{c}
VkResult vkCreateInstance(
const VkInstanceCreateInfo*                 pCreateInfo,
const VkAllocationCallbacks*                pAllocator,
VkInstance*                                 pInstance);
		\end{minted}
		
	Let's take this apart:
		\begin{itemize}
			\item return type \cil{vkResult}: a C "enum", which contains a bunch of  constants indicating the result of different Vulkan commands: in this case, success (i.e. successful creation of an instance), or some sort of a failure;
			
			\item argument \cil{pCreateInfo}: a pointer (a C pointer is similar to a Rust reference, but with some important differences ) to a \cil{vkInstanceCreateInfo} "struct";
			
			\item argument \cil{pAllocator}: a pointer to a \cil{vkAllocationCallbacks} "struct" whose members contain various functions you might have written to help the physical device organize its memory usage---we will tend to go simple, and not provide anything, in which case the device will use its default memory management routines;
			
			\item argument \cil{pInstance} an \inquotes{opaque pointer} to an instance (an opaque pointer is a C concept which provides a pointer to the \inquotes{tip} of some data structure: i.e. it gies you a handle to some data structure, whose internals aren't transparent to you).
		\end{itemize}
	
	Let's now have a closer look at \cil{vkInstanceCreateInfo} "struct" definition:
		\begin{minted}{c}
typedef struct VkInstanceCreateInfo {
	VkStructureType             sType;
	const void*                 pNext;
	VkInstanceCreateFlags       flags;
	const VkApplicationInfo*    pApplicationInfo;
	uint32_t                    enabledLayerCount;
	const char* const*          ppEnabledLayerNames;
	uint32_t                    enabledExtensionCount;
	const char* const*          ppEnabledExtensionNames;
} VkInstanceCreateInfo;
		\end{minted}
	A brief description of the members:
		\begin{itemize}
			\item \cil{sType}: indicates the type of the structure, in this case "VK\_STRUCTURE\_TYPE\_INSTANCE\_CREATE\_INFO"---this is useful because in C, you might sometimes get a typeless (\cil{void*}) pointer to a particular struct, and to determine what kind of struct it is, you could query the \cil{sType} field;
			
			\item \cil{pNext}: usually set to \cil{NULL}, and can be used to pass additional structures (whose type will be defined by the \cil{sType} field), sometimes needed by API extensions;
			
			\item \cil{flags}: currently no flags defined, set to "0";
			
			\item \cil{pApplicationInfo}: pointer to a \cil{VkApplicationInfo} structure which we will study next;
			
			\item \cil{ppEnabledLayerNames}: in this tutorial, we will not be using layers, so we can set this to \cil{NULL};
			
			\item \cil{enabledLayerCount}: length of the \cil{ppEnabledLayerNames} list, should be zero if \cil{ppEnabledLayerNames == NULL};
			
			\item \cil{ppEnabledExtensionNames}: at this point in the tutorial, we are not using extensions, so we'll be setting this to \cil{NULL};
			
			\item \cil{enabledExtensionCount}: length of the \cil{ppEnabledExtensionNames} list;
		\end{itemize}
	The \cil{vkInstanceCreateInfo} "struct" contains a \cil{VkApplicationInfo} "struct" which has the following definition:
		\begin{minted}{c}
typedef struct VkApplicationInfo {
	VkStructureType    sType;
	const void*        pNext;
	const char*        pApplicationName;
	uint32_t           applicationVersion;
	const char*        pEngineName;
	uint32_t           engineVersion;
	uint32_t           apiVersion;
} VkApplicationInfo;
		\end{minted}
	This structure is meant to provide some information regarding your application; a brief overview of its members:
		\begin{itemize}
			\item \cil{sType}, \cil{pNext}: common features of many Vulkan info "struct"s, see the \cil{vkInstanceCreateInfo} "struct"'s member overview, as these are the same;
			
			\item \cil{pApplicationName}, \cil{applicationVersion}, \cil{pEngineName}, \cil{engineVersion}: fields that you may fill out if you desire to annotate general report/debugging data, or if you want a tip a driver with specific behaviour for your application implemented;
			
			\item \cil{apiVersion}:  this field communicates the major, minor, and patch levels of the Vulkan API used by the application; we'll be using "VK\_API\_VERSION\_1\_0" (major is "1", minor is "0").
		\end{itemize}
	
	With these prototypes in mind, let's see how we can use Vulkan through Ash. Open up "/init-instance/src/main.rs"! Some points for your consideration:
		\begin{itemize}
			\item note comments explaining what \ril{use} statements;
			
			\item note the \ril{unsafe} block;
			
			\item note how for fields like \cil{pApplicationName} we create a \ril{std::ffi::CString} and then pass it \inquotes{raw} (i.e. as a pointer) by calling \ril{as_ptr};
			
			\item note how \ril{vk::StructureType} is used to fill out \ril{s_type} fields;
			
			\item can you explain how the \ril{flags} field is filled out? (look up the definition of the \ril{vk::InstanceCreateInfo} "struct" in \href{https://docs.rs/ash}{Ash's documentation} and then answer: what type is \ril{flags}? How is the \ril{std::Default} trait implemented for it?);
			
			\item to actually use Vulkan, we first initialize an \ril{ash::Entry} "struct" which contains \ril{FunctionPointers} and their supporting infrastructure into Vulkan's C implementation;
			
			\item the \ril{ash::Entry} "struct" also has some \ril{impl}s which put syntactic sugar around calling functions like \ril{vkCreateInstance}, in particular the function \ril{create_instance}---can you find where that function is implemented? (hint: open up \href{https://docs.rs/ash}{Ash's documentation}, and 1) figure out where the \ril{EntryV1_0} trait is defined, 2) figure out where \ril{Entry<V>} is defined, and 3) how is the \ril{EntryV1_0} implemented for \ril{Entry<V1_0>}?);
			
			\item note how we have to manually destroy the instance.
		\end{itemize} 
	
	Don't forget to call "cargo run" for "init-instance" to make sure that everything compiles. 
	
\section{\texttt{enumerate-devices}}
	Now that we know how to initialize an instance, let us learn how to use it to enumerate the physical devices on our system. In general, obtaining a list of stuff is a fairly common operation in Vulkan, so there's a generalized pattern behind what we want to do on the C side of things:
		\begin{enumerate}
			\item Application calls the function with a valid pointer to an integer for the count argument and a \cil{NULL} for the pointer argument.
			
			\item The API fills in the count argument with the number of objects in the list.
			
			\item The application allocates enough space to store the list.
			
			\item The application calls the function again with the pointer argument pointing to the space just allocated.
		\end{enumerate}
	
	Alright, so what does the function prototype for \cil{vkEnumeratePhysicalDevices} look like?
	\begin{minted}{c}
VkResult vkEnumeratePhysicalDevices(
	VkInstance                                  instance,
	uint32_t*                                   pPhysicalDeviceCount,
	VkPhysicalDevice*                           pPhysicalDevices);
	\end{minted}
	
	In Rust, \ril{ash::Instance} object has an \ril{impl} function which calls \cil{vkEnumeratePhysicalDevices} and returns the result. Have a look at how it works (see documentation for \ril{ash::Instance}, and click "src"): \href{https://gist.github.com/bzm3r/175cd2b63db8f783ed968df20462be67}{gist link for annotated \texttt{enumerate\_physical\_devices}}.
		
	So under the hood, Ash follows exactly the pattern we noted above. Have a look at the source for "enumerate-devices", where we query for the list of the physical devices on our system, and print out how many we found.
	
\section{Next}
\end{document}
